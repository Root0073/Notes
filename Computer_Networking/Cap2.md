# TCP service model
##  TCP提供的服务的总结表哥
1. 两个应用程序之间的可靠的字节流
2. TCP使用四种机制来确保通信的可靠性: 当TCP层接收到数据时，他会向发送方发送一个确认包，告知数据已经正确到达

校验和用于检测数据是否损坏，TCP头部携带一个校验和，覆盖头部和段内的数据，用于检测段在传输过程中是否损坏

序列号用于检测数据是否丢失，每个段的头部携带该段在字节流中的第一个字节的序列号

流量控制防止接收方过载 接收方会不断告知发送方是否可以继续发送

3. TCP会按正确的数据将数据传递给应用程序 如果段在到达主机B时顺序混乱，TCP层会使用序列号将他们重新排列到正确的位置

4. TCP通过控制拥塞为整个网络提供了一个表面 TCP试图在所有使用网络的TCP连接，之间平均分配网络容量
## TCP Segment Format
目标端口告诉TCP层，这些字节应该传递给另一端的哪个应用程序，当一个新的连接开始时，应用程序会告诉TCP要与哪个服务建立连接

原端口告诉另一端的TCP层，他应该使用哪个端口来发送回数据 当一个新的连接开始时，连接的发起者会生成一个唯一的源端口号，以区分该链接与主机A和B之间到同一服务的任何其他连接

序列号表示TCP数据字段中的第一个字节在字节流中的位置

确认序列号告诉另一端我们期望接收的下一个字节，他还表示我们已经成功的接收到这个字节之前的所有字节

每个段中都有两个方向的序列号，这样他就可以在反方向传输的数据段上捎带确认信息

16位校验和根据整个头部和数据计算的，有助于接收方测验数据是否损坏

头部长度字段告诉我们TCP头部有多长

由一系列标志用于在连接的两端之间传递信息

ACK标志告诉我们确认序列号是有效的

SYN标志告诉我们正在发送同步信号，这是建立连接的三次握手的一部分

FIN标志则表示关闭连接的一个方向

PSH标志告诉我们当数据到达时另一端的TCP层应该立即交付数据

## The Unique ID of a TCP connect
TCP连接由TCP和IP头中的五部分信息唯一标识
IP愿地址和目的地址唯一标识了原点，而TCP的IP协议ID告诉我们这是一个TCP连接

主机A为每个新连接递增源端口号

TCP连接在初始化时会使用一个随机的出事序列号来引用字节流中的字节

# UDP Service Model
UDP所做的就是接收数据应用，创建一个UDP数据报，然后将其交付给网络层

UDP的头部只有四个：

源端口指示数据来自哪个应用

目标端口指示数据应该被传递到另一端主机的哪个应用，UDP的端口号与TCP中的作用相同

16位长度字段指定了整个UDP数据报的长度，单位是字节，该值至少为8字节，因为这是UDP

在使用IPv4时，UDP校验和是可选的，如果发送方不包含校验和，该字段将被填满0，如果使用了UDP校验和，那么他将覆盖UDP头部和数据

UDP的校验和的计算还包括IPv4头部的一部分，计算包括IP源地址和目标地址以及协议ID

UDP中的端口与TCP中的一致

他有一下三个特性：
1. 一种无连接的数据报服务
2. 如果应用在意顺序他需要自己排序
3. 传输不可靠

UDP只是在IP上面做了简单的封装

# ICMP Service Model
互联网控制消息协议，主要用于报告错误和诊断网络层

有三种机制来确互联网中的网络层正常工作

1. ip 
2. 路由器内部的路由表
3. ICMP

ICMP帮助在终端主机和路由器之间传递网络层的信息，通常用于报告错误情况

ICMP的model非常简单：
它允许发送一个包含错误报告的自包含消息，他会取走ip数据报的头部和前八位有效负载，附上状态和代码并将整个内容放入一个新的ip数据报中，然后将其发送出去

## PING
ping命令用于查看另一个主机的状态

# End to End Principle
所有额外的附加功能只有在通信系统端点的应用程序的知识和帮助下，才完全且准确的实现，因此将该功能作为通信本身的一个特性来提供是不可能的

例如如果你想确保你的引用程序安全，你需要在应用程序里实现端到端的安全措施

确保文件正确到达的唯一方法就是进行端到端的检查

如果想实现端到端的数据可靠传输，那么需要像tcp这样的端到端可靠协议

## Strong end to end

# Error Detection: 3 schemes
第一种常用的错误检测是校验和，优点在于计算速度快且成本低

他们的错误检测能力较弱

第二种是循环冗余编码器(CRC)，成本远高于校验和但是更健壮，他计算多项式的余数

第三章是MAC，消息验证码

它会将数据包和一些秘密信息结合，从技术上讲，消息验证码没有错误检测的保证，如果你反转一个比特，最终可能会得到完全相同的MAC，他在安全方面作用非常好

校验和只能检查单比特错误，CRC能检测小于等于CRC长度的比特错误，MAC不能确保检测错误

# Finite state machines
如果你想完全明确和细致，你应该为每个状态指定每个事件发生时的情况

# Stop and Wait
